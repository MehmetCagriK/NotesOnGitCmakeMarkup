What happens when you initialize a repository? Why do you need to do it?

How is the staging area different from the working directory and the repository?
What value do you think it offers?

Q: How can you use the staging area to make sure you have one commit per logical
change?
A: You can use "git add <filename>" whenever you are done with file. This way 
your changes later on the file would not get into commit by mistake.
What are some situations when branches would be helpful in keeping your history
organized? How would branches help?

How do the diagrams help you visualize the branch structure?
Diagrams help us to see the direction of relationship between commits. They 
also show what "git log" can not show because of limitations.
What is the result of merging two branches together? Why do we represent it in
the diagram the way we do?

What are the pros and cons of Git's automatic merging vs. always doing merges
manually?

GIT CONCEPTS RECAP
  1. GIT REPOSITORY: 
     Repository is a working directory for git. It includes all
     user provided files that are served by git version control system and some
     git specific files(under ..git directory). The .git folder contains all 
     the information that is necessary for your project in version control and 
     all the information about commits, remote repository address etc. It also
     contains a log which stores your commit history so that you can roll back
     to history.Any directory can be Git Repository. Just create a directory or
     navigate into one. Once you are in desired directory, use command 
     "git init" to convert it to Git repository.
  
  2. STAGING AREA:
     Git allows even more control before committing changes. To commit changes
     in the files, use "git add <filename>" command to add them into staging 
     area. Files put into staging area are will be committed to repository when
     "git commit" command is used.
     Users do not have to add all their changed files into staging area and 
     might want to include some changes in another commit. When you add files
     to staging area, git takes a snapshot of that file in that time, meaning
     changes on a file that is added to staging area does not affect the 
     version in the staging area.
       - "git reset HEAD -- <file>" : remove files from staging area.
       - "git diff --cached" : show the changes between last commit and the 
         files in the staging area.
       - "git diff" : Show the changes between working files and staged files
  
  3. ADD
     "<git add <filename>" command adds the file's current version into staging
     area. Only changes in the staging area is candidate to be committed. 
     "git reset HEAD -- <file>" command reverses this 
  4. COMMIT:
     Commits are snapshots of the files at the time when <git commit> command
     is used. Only the changes in the staging area are committed. It can be 
     summarized as "commit_next = commit_current + staging_area". When 
     committing, Git asks user to enter a short comment about changes and 
     after that, commit is created. You can also use 
     "git commit -m "Commit Message" to add comment preemptively. Git commit 
     messages are generally in the command format like "Add a cake recipe".

     Note that Git does not commit the latest version of file in the working
     directory. It commits latest version in staging area. So it is possible
     that changing a file after putting it into staging area. When you commit,
     changes after staging is not saved into repository. Those changes are not
     also lost after commit as Git does not modify the files in the working.
     See the example below;

     Filename                    : lesson
     Content in working directory: "abc"
     git add lesson              : add lesson to staging area
     Content in staging area     : "abc"
     Change content in work dir  : "abcdef" (Content changed after staging)
     Content in working directory: "abcdef"
     Content in staging area     : "abc"    (Staging area is not affected)
     git commit                  : commit the changes in staging area
     Content in repository       : "abc"    (Only staged changes committed)
     Content in working directory: "abcdef" (Last version is preserved)

  5. CLONE:
     "<git clone <repository_url>" command clones the repository with given url
     to local storage. Clone also brings whole history of the repository.

  6. DIFF
     - "git diff <commit1> <commit2>" command shows the changes from left to 
       right. It can be summarized as; 
       git diff  <commit1> <commit2> = <commit2> - <commit1>
     - "git diff --cached" : show the changes between last commit and the 
       files in the staging area.
     - "git diff" : Show the changes between working files and staged files.
  7. STATUS
     <git status> command shows modified/deleted/added/untracked files and 
     files in the staging area and general info about current branch.

  8. LOG
     "git log" command shows commit history as commit SHA1 key, author name and
     email, date and commit comment.
     "git log n1" shows last 1 commit log. You can change 1 to any number.

  9. WORKING DIRECTORY
     Working directory is the directory on the local storage. It shall not be 
     understood as last commit or repository etc. For further information, 
     refer to 1, 2, 3, 4.

  10. BRANCH
      When you want to experiment some feature on the project you work or 
      simply want to make changes in an isolated(to master) fashion, you can
      create branches for the task. Branches are simply labels for commits.
      
      The default branch is the master branch when a git repository is 
      initialized and it is generally main branch. If you recall the warning 
      message about "detached HEAD state", it means you are on a commit that is
      not labeled with a branch name. Git warns user because of commits done 
      onto this commit will not be done on master branch. 

      You can checkout to a branch like you can checkout to a commit. Use 
      "git checkout <bracnh_name>". When you commit to the new branch, label
      is applied to new commit also. So checking out branch will not go to
      root of the branch but to tip of that branch.
      Note: Remember to checkout to the branch after creating it. Git does not
      automatically checkout to the newly created branch. You can use 
      "git checkout -b <branch_name>" to automatically checkout after creation.
      Note: You can use "git branch" to list all branches and the checked-out 
      one(annotated with *).

      Branches(or commits in general can also see their ancestor commits. They
      don' t see if they are not merged.

  11. MERGE
      When there are multiple branches and each of them have changes on them,
      to incorporate changes from one branch to another is called merging.
      Simple merge logic is like below

      File Content(As lines)
      Original : ABD
      Jake     : BDE
      Rachel   : ABCD
      
      Line analysis
      A: Jake deleted this line. This line shall NOT be in the final version.
      B: This line exists in both versions. It shall be in the final version.
      C: Rachel added this line. It shall be in the final version.
      D: This line exists in both versions. It shall be in the final version.
      E: Jake added this line. It shall be in the final version.

      To merge two different branches, follow the list below;
      1. Checkout to the branch you wanna update with changes from the other.
      2. Type "git merge <branch_to_update> <branch_has_change>.
      3. If there is a conflict go to step 4, if not, go to step 6.
      4. Resolve the conflicts and save the files.
      5. Add the files to staging area and commit them. END!
      6. Git automatically merges commits. END!

      If there is a conflict happens during merge, Git modifies the conflicted
      files with some symbols to show what is the version of the file segment
      in <branch_to_update>, <branch_has_change> and their common ancestor.
       
      Example of modified conflicted file is below
      /code
        <<<<<<< HEAD
        foo
        =======
        bar
        >>>>>>> <branch_has_change> 
      /code

      Code segment "foo" belongs to the <branch_to_update>.
      Code segment "bar" belongs to the <branch_has_change>.
      HEAD means the branch currently checked out <branch_to_update>.

      A note about git merge:
      "git merge" will also include the currently checked-out branch in the 
      merged version. So if you have branch1 checked out, and you run git merge
      branch2 branch3, the merged version will combine branch1 as well as 
      branch2 and branch3. That’s because the branch1 label will update after 
      you make the merge commit, so it’s unlikely that you didn’t want the 
      changes from branch1 included in the merge. For this reason, you should 
      always checkout one of the two branches you’re planning on merging before 
      doing the merge. Which one you should check out depends on which branch 
      label you want to point to the new commit.

      Since the checked-out branch is always included in the merge, you may 
      have guessed that when you are merging two branches, you don't need to 
      specify both of them as arguments to git merge on the command line. If 
      you want to merge branch2 into branch1, you can simply git checkout 
      branch1 and then type git merge branch2. The only reason to type git 
      merge branch1 branch2 is if it helps you keep better mental track of 
      which branches you are merging.

      Also, since the two branches are merged, the order in which they are 
      typed into the command line does not matter. The key is to remember that
      git merge always merges all the specified branches into the currently 
      checked out branch, creating a new commit for that branch.

      In general, it’s very common that if you make a branch, either an 
      experimental branch or to work on a new feature, you want to periodically
      merge master into that branch. This is because master usually contains 
      the official version of the code, and it’s common to want experimental 
      changes to include all of the changes to master.
  
  12. SHOW
      "git show <commitSHAKey>" command shows changes between commit and its 
      parent.
